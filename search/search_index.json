{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"template-devcontainer Docs","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This is the documentation site for <code>compilerla/template-devcontainer</code>.</p> <p><code>template-devcontainer</code> is a template repository with a minimal VS Code devcontainer setup.</p> <p><code>template-devcontainer</code> can be used as the basis for another language-specific devcontainer, or as a quick ready-made Linux development environment.</p> <p>Docs are built using <code>mkdocs</code>. This site is built using <code>mkdocs-material</code>.</p>"},{"location":"#use-this-template","title":"Use this template","text":"<p>Generate a new repository from the template</p>"},{"location":"#why","title":"Why?","text":"<p>In no particular order, here are some reasons Compiler likes to use devcontainers as part of our software engineering workflow:</p> <p>Read more in our blog post: How to support a platform-agnostic engineering team with VS Code Dev Containers.</p> Reason More Cross-platform With only VS Code and Docker as dependencies, devcontainers allow developers on Linux, Mac, and Windows to work in a consistent environment, no matter the project\u2019s stack Easily extendable The VS Code community maintains a library of extensions to add features and functionality to the development environment; individual personalizations can be made via dotfiles Enforce best practices Baking linters, <code>pre-commit</code> checks, test runners, and more into the devcontainer ensures the team\u2019s best practices are no-brainer always-on features of the development workflow Rapid onboarding By minimizing the steps from <code>git clone</code> to getting tests to pass or the app running locally, devcontainers make it easier to onboard as a new developer and spend time contributing instead of wallowing in environment setup Unified code style With common editor settings like code formatting on save, standard indentation characters and spacing, consistent line endings, and more, the team never has to worry about what the code looks like or accidentally committing BOMs"},{"location":"#prior-art","title":"Prior art","text":"<p>This template was informed by our work on recent projects as a remote-first, cross-platform development team.</p> <p>Some of our recent work built on the devcontainer pattern includes:</p> <ul> <li><code>cal-itp/benefits</code> (Python/Django web app)</li> <li><code>cal-itp/eligibility-api</code> (Python API library)</li> <li><code>cal-itp/eligibility-server</code> (Python/Flask API server)</li> <li><code>cal-itp/hashfields</code> (Python CLI tool)</li> <li><code>cal-itp/mobility-marketplace</code> (Jekyll static site)</li> <li><code>compilerla/compiler.la</code> (Jekyll static site)</li> <li><code>compilerla/conventional-pre-commit</code> (Python pre-commit hook)</li> </ul>"},{"location":"features/dependabot/","title":"Dependabot","text":"<p>Configuration</p> <ul> <li>Main config file: <code>.github/dependabot.yml</code></li> </ul>"},{"location":"features/dependabot/#introduction","title":"Introduction","text":"<p>Dependabot is GitHub\u2019s service for keeping repository dependencies up to date and staying ahead of security vulnerabilities in open source packages.</p> <p>Based on the configured package ecosystems, Dependabot will send alerts to repository administrators for security-related events in referenced packages. Dependabot will also open Pull Requests to update dependencies when fixes are published.</p>"},{"location":"features/dependabot/#features","title":"Features","text":""},{"location":"features/dependabot/#github-actions","title":"GitHub Actions","text":"<p>Watches for updates to GitHub Actions workflow steps, e.g. <code>actions/checkout</code>.</p> <p>Read more about Keeping actions up to date with Dependabot</p>"},{"location":"features/devcontainer/","title":"Devcontainer","text":"<p>Configuration</p> <ul> <li>Main config file: <code>devcontainer.json</code></li> <li>Dependencies: <code>requirements.txt</code></li> <li>Dockerfile: <code>Dockerfile</code></li> <li>Service definition: <code>compose.yml</code></li> <li>Finalization: <code>postAttach.sh</code></li> </ul>"},{"location":"features/devcontainer/#introduction","title":"Introduction","text":"<p>VS Code can be used together with Docker via the Remote - Containers extension to enable a container-based development environment.</p> <p>As a remote-first, cross-platform development team, Compiler uses devcontainers to ease the onboarding and local development process for our engineering team, and to ensure our Open Source projects are widely accessible and easily reproducable for others.</p>"},{"location":"features/devcontainer/#the-image","title":"The image","text":"<p>The devcontainer\u2019s image is called <code>compilerla/template-devcontainer</code>.</p>"},{"location":"features/devcontainer/#base","title":"Base","text":"<p>The image is based on <code>python:3.11</code>, to ease installation of common tooling like <code>mkdocs</code> and <code>pre-commit</code>.</p>"},{"location":"features/devcontainer/#setup","title":"Setup","text":"<p>Most setup is performed as the non-root <code>$USER</code>, with a default of <code>compiler</code>.</p> <p>A home directory is created at <code>/home/$USER</code> and the working directory is set to <code>/home/$USER/src</code>.</p> <p>Additional command-line tools included in the image:</p> <ul> <li><code>curl</code></li> <li><code>git</code></li> <li><code>pip</code></li> <li><code>wget</code></li> </ul> <p>See the official <code>python</code> image on DockerHub for more.</p>"},{"location":"features/devcontainer/#requirements","title":"Requirements","text":"<p>The <code>.devcontainer/requirements.txt</code> file lists <code>PyPI</code> packages installed by default into the devcontainer.</p>"},{"location":"features/devcontainer/#extensions","title":"Extensions","text":"<p>The <code>devcontainer/devcontainer.json</code> file lists VS Code extensions installed with the devcontainer. These include:</p> <ul> <li>GitLens for supercharing the <code>git</code> experience</li> <li>Git Graph for visualizing the <code>git</code> commit history</li> <li>markdownlint for Markdown linting and style checking directly in VS Code</li> <li>Mermaid Markdown Syntax Highlighting for editing Mermaid diagrams in documentation</li> <li>Prettier for good default formatting and linting of most file types</li> </ul>"},{"location":"features/docs/","title":"Documentation","text":"<p>Configuration</p> <ul> <li>Main config file: <code>mkdocs.yml</code></li> <li>Additional dependencies: <code>docs/requirements.txt</code></li> <li>Installation: <code>Dockerfile</code></li> <li>Service definition: <code>compose.yml</code></li> </ul>"},{"location":"features/docs/#introduction","title":"Introduction","text":"<p>The devcontainer includes a system for building project documentation, useful for developing and publishing a full-featured documentation website, either as a standalone entity or as part of a software library/project.</p> <p>Documenation is written in plaintext files using the popular Markdown syntax. Besides being widely supported and straightfowrad to edit in a variety of platforms, documentation written as Markdown is easily versioned by systems like <code>git</code>.</p> <p>The Python-based <code>mkdocs</code> tool builds Markdown documentation files into a website structure.</p> <p>Themeing and additional documentation content functionality are provided by the <code>mkdocs-material</code> extension.</p>"},{"location":"features/docs/#features","title":"Features","text":"<ul> <li>Complete color themes for both light and dark modes</li> <li>Google Analytics support (with a <code>G-xxxxxxxxxx</code> configuration)</li> <li>Site search</li> <li>Icons from <code>FontAwesome</code></li> <li>Diagram support via Mermaid.js</li> <li>Better site navigation with <code>awesome-pages</code></li> <li>Redirect old URLs when content moves around with <code>redirects</code></li> </ul> <p>See the <code>mkdocs-material</code> Reference for more supported features.</p>"},{"location":"features/editor/","title":"Editor","text":"<p>Configuration</p> <ul> <li>Main config file: <code>.vscode/settings.json</code></li> </ul>"},{"location":"features/editor/#introduction","title":"Introduction","text":"<p>The core editor experience and configuration of VS Code</p>"},{"location":"features/editor/#features","title":"Features","text":""},{"location":"features/editor/#shared-settings","title":"Shared settings","text":"<ul> <li><code>utf-8</code> file encoding</li> <li><code>\\n</code> newlines, final newlines trimmed, final newline added</li> <li>trailing whitespace trimmed</li> <li>Prettier as the default file formatter</li> </ul>"},{"location":"features/editor/#custom-settings","title":"Custom settings","text":"<p>Further personalization can be loaded by individual developers using a dotfiles repository.</p>"},{"location":"features/pre-commit/","title":"pre-commit","text":"<p>Configuration</p> <ul> <li>Main config file: <code>.pre-commit-config.yaml</code></li> <li>Initialization: <code>Dockerfile</code></li> <li>Finalization: <code>postAttach.sh</code></li> </ul>"},{"location":"features/pre-commit/#introduction","title":"Introduction","text":"<p><code>pre-commit</code> is a Python framework for running \u201chooks\u201d during various points in the <code>git commit</code> workflow.</p> <p><code>pre-commit</code> hooks do things like enforce commit message formatting and check and automatically clean up file formatting.</p> <p>Integrating these checks with the <code>git commit</code> workflow ensures every commit follows team conventions and reduces the chance for simple syntax errors and other hidden bugs.</p>"},{"location":"features/pre-commit/#features","title":"Features","text":""},{"location":"features/pre-commit/#conventional-commits","title":"Conventional Commits","text":"<p>Compiler follows the Conventional Commits specification for writing commit messages.</p> <p><code>compilerla/conventional-pre-commit</code> is a <code>pre-commit</code> hook that enforces this convention for every commit.</p>"},{"location":"features/pre-commit/#markdownlint","title":"Markdownlint","text":"<p><code>markdownlint</code> is a static analysis tool (linter) for Markdown documents.</p> <p>The related <code>markdownlint-cli</code> tool can be used as a <code>pre-commit</code> hook.</p>"},{"location":"features/pre-commit/#pre-commit-hooks","title":"Pre-Commit Hooks","text":"<p><code>pre-commit-hooks</code> is a collection of useful hooks maintained by the <code>pre-commit</code> team.</p>"},{"location":"usage/generate/","title":"Generate a new repository","text":"<p>See also</p> <p>GitHub docs: Creating a repository from a template</p> <p>The simplest way to get started is to create a new repository from the template:</p> <p>Generate a new repository from the template</p> <p>This will copy the files and directory structure from the template into a new repository of your choosing.</p> <p>If you intend to publish a Documentation website, be sure to make this a <code>Public</code> repository and check the box to <code>Include all branches</code>:</p> <p></p>"},{"location":"usage/reference-image/","title":"Reference the pre-built image","text":"<p>Configuration</p> <ul> <li>Workflow file: <code>.github/workflows/publish-devcontainer.yml</code></li> <li>GHCR Packages: <code>compilerla/template-devcontainer</code></li> <li>Minimal devcontainer.json: <code>devcontainer.pre-built.json</code></li> </ul> <p><code>template-devcontainer</code> maintains a GitHub Actions workflow that publishes Docker images to GitHub Container Registry (GHCR).</p> <p>The publish is triggered for every push to the <code>main</code> branch, and multiple image tags are created:</p> <ul> <li><code>main</code> uses the default Python version of 3.11</li> <li><code>main_3.10</code> uses Python 3.10</li> <li><code>main_3.12</code> uses Python 3.12</li> </ul> <p>There are also corresponding tags for the git SHA of the commit on <code>main</code> that triggered the build (e.g. <code>sha</code>, <code>sha_3.10</code>, and <code>sha_3.12</code>).</p> <p>This makes the pre-built devcontainer image available for use in other projects, potentially decreasing startup and onboarding time even further.</p>"},{"location":"usage/reference-image/#from-a-devcontainerjson-configuration","title":"From a <code>devcontainer.json</code> configuration","text":"<p>The pre-built devcontainer image can be used as the basis for another <code>devcontainer.json</code> configuration, similar to how one might reference any other image on Docker Hub or GHCR:</p> <pre><code>{\n  \"name\": \"compilerla/template-devcontainer-pre-built\",\n  \"image\": \"ghcr.io/compilerla/template-devcontainer:main\",\n  // initialize pre-commit hooks on attach (assumes .pre-commit-config.yaml)\n  \"postAttachCommand\": \"pre-commit install --overwrite\"\n  // other settings\n}\n</code></pre> <p>Our <code>devcontainer.pre-built.json</code> shows a minimal example to get a devcontainer running with the same configuration as the normal <code>devcontainer.json</code>, using the pre-built image.</p> <p>See the full <code>devcontainer.json</code> Reference for details.</p>"},{"location":"usage/reference-image/#using-docker-compose","title":"Using Docker Compose","text":"<p>In a <code>docker-compose.yml</code> or <code>compose.yml</code> file, you can reference the GHCR image directly in a service definition:</p> <pre><code>services:\n  myservice:\n    image: ghcr.io/compilerla/template-devcontainer:main\n    volume: ./:/home/compiler/src\n</code></pre> <p>Note the <code>volume</code> entry mapping the current directory (with the <code>compose.yml</code> file) into the devcontainer working directory.</p> <p>And then starting the service with:</p> <pre><code>docker compose up myservice\n</code></pre> <p>This is perhaps a less useful approach, with the default <code>CMD</code> and <code>ENTRYPOINT</code> set in such a way as to make the container essentially hang (useful when attaching from VS Code).</p>"},{"location":"usage/run-local/","title":"Run the devcontainer locally","text":"<p>See also</p> <p>VS Code tutorial: Remote development in Containers</p>"},{"location":"usage/run-local/#prerequisites","title":"Prerequisites","text":""},{"location":"usage/run-local/#docker","title":"Docker","text":"<p>Docker is required; the easiest way to get Docker is by downloading and installing Docker Desktop for Linux, Mac (including Apple Silicon!) and Windows.</p>"},{"location":"usage/run-local/#vs-code","title":"VS Code","text":"<p>You will also need VS Code and the <code>Remote - Containers</code> extension installed.</p>"},{"location":"usage/run-local/#source-code","title":"Source code","text":"<p>Ensure you have a local copy of this template repository:</p> <pre><code>git clone https://github.com/compilerla/template-devcontainer\n</code></pre> <p>Or another repository you generated from this template.</p>"},{"location":"usage/run-local/#open-the-repo-in-vs-code","title":"Open the repo in VS Code","text":"<p>From the command line:</p> <pre><code>code /path/to/repository\n</code></pre> <p>Or from the VS Code UI:</p> <p><code>File &gt; Open Folder &gt; /path/to/repository</code></p>"},{"location":"usage/run-local/#reopen-in-devcontainer","title":"Reopen in devcontainer","text":"<p>At this point, the VS Code UI should prompt you to reopen the folder in the devcontainer:</p> <p></p>"},{"location":"usage/run-local/#rebuild-and-reopen","title":"Rebuild and Reopen","text":"<p>To completely rebuild the devcontainer from scratch and reopen the VS Code window, attached to the running devcontainer:</p> <ol> <li>Bring up the VS Code Command Palette with: <code>Ctrl/Cmd + Shift + P</code></li> <li>Enter <code>Remote-Containers</code> to filter the list</li> <li>Enter or select the <code>Rebuild and Reopen in Container</code> option</li> </ol>"},{"location":"usage/run-local/#reopen","title":"Reopen","text":"<p>To reopen VS Code attached to the most recently built and used devcontainer (the build is skipped if not needed):</p> <ol> <li>Bring up the VS Code Command Palette with: <code>Ctrl/Cmd + Shift + P</code></li> <li>Enter <code>Remote-Containers</code> to filter the list</li> <li>Enter or select the <code>Reopen in Container</code> option</li> </ol>"},{"location":"usage/run-local/#close-the-devcontainer","title":"Close the devcontainer","text":"<p>From within the devcontainer, to close the connection and reopen VS Code on your local (host) machine:</p> <ol> <li>Bring up the VS Code Command Palette with: <code>Ctrl/Cmd + Shift + P</code></li> <li>Enter <code>Remote-Containers</code> to filter the list</li> <li>Enter or select the <code>Reopen Folder Locally</code> option</li> </ol>"}]}